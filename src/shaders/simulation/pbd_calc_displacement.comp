#version 450

layout(local_size_x = 256) in;

layout(push_constant) uniform Constants
{
    vec4 aabb_min;
    vec4 aabb_max;
    uint particle_count;
    float rest_density;
    float smoothing_radius;
    float smoothing_radius_sq;
    float spiky_kernel_factor;
    float spiky_grad_kernel_factor;
    float constraint_epsilon;
    float relaxation_factor;
    float grid_size;
    uint max_neighbors;
}
constants;

layout(binding = 0) readonly buffer PredictedPositionBuffer
{
    vec4 predicted_positions[];
};

layout(binding = 1) readonly buffer LambdaBuffer
{
    float lambdas[];
};

layout(binding = 2) readonly buffer ContactsBuffer
{
    uint contacts[];
};

layout(binding = 3) readonly buffer ContactCountsBuffer
{
    uint contact_counts[];
};

layout(binding = 4) buffer DeltaPositionBuffer
{
    vec4 delta_positions[];
};

// Spiky kernal
// W_spiky_grad(r, h) = -45 / (π * h^6) * (h - |r|)^2 * r / |r|
vec3 spiky_gradient(vec3 r_vec, float r, float h)
{
    if (r >= h || r == 0.0) return vec3(0.0);
    
    const float min_distance = 1e-6;
    if (r < min_distance) {
        return vec3(0.0);
    }
    
    float h_minus_r = h - r;
    float factor = constants.spiky_grad_kernel_factor * h_minus_r * h_minus_r / r;

    vec3 gradient = factor * r_vec;
    float gradient_magnitude = length(gradient);
    const float max_gradient = 1e6;
    
    if (gradient_magnitude > max_gradient) {
        gradient = normalize(gradient) * max_gradient;
    }
    
    return gradient;
}

void main()
{
    uint i = gl_GlobalInvocationID.x;
    if (i >= constants.particle_count)
        return;

    vec3 pos_i = predicted_positions[i].xyz;
    float lambda_i = lambdas[i];
    
    // Position coorinate：Δp_i = (1/m_i) * λ_i * ∇_i C_i
    vec3 displacement = vec3(0.0);
    
    uint neighbor_count = contact_counts[i];
    const float mass = 0.001;
    
    // 计算约束梯度：∇_i C_i = (1/ρ_0) * ∇_i ρ_i
    vec3 gradient_i = vec3(0.0);
    
    for (uint n = 0; n < neighbor_count; n++)
    {
        uint j = contacts[i * constants.max_neighbors + n];
        if (j >= constants.particle_count || j == i)
            continue;
            
        vec3 pos_j = predicted_positions[j].xyz;
        vec3 r_vec = pos_i - pos_j;
        float r = length(r_vec);
        
        if (r < constants.smoothing_radius)
        {
            vec3 density_grad;
            
            if (r > 0.0) {
                density_grad = mass * spiky_gradient(r_vec, r, constants.smoothing_radius);
            } else {
                // 特殊情况：完全重叠的粒子 - 与lambda计算保持一致
                // 基于粒子ID差异生成确定性的排斥方向
                vec3 artificial_direction;
                if (i < j) {
                    artificial_direction = vec3(-1.0, 0.0, 0.0);
                } else {
                    artificial_direction = vec3(1.0, 0.0, 0.0);
                }
                
                artificial_direction.y = sin(float(i) * 2.0) * 0.5;
                artificial_direction.z = cos(float(i) * 3.0) * 0.5;
                artificial_direction = normalize(artificial_direction);

                float artificial_gradient_magnitude = mass * constants.spiky_grad_kernel_factor * 
                    constants.smoothing_radius * constants.smoothing_radius;
                
                density_grad = artificial_gradient_magnitude * artificial_direction;
            }
            
            gradient_i += density_grad;
        }
    }
    
    // 转换为约束梯度：∇_i C_i = (1/ρ_0) * ∇_i ρ_i
    vec3 constraint_grad_i = (1.0 / constants.rest_density) * gradient_i;
    
    // 应用松弛因子和拉格朗日乘数：Δp_i = λ_i * ∇_i C_i * relaxation_factor
    displacement = lambda_i * constraint_grad_i * constants.relaxation_factor;
    
    float max_displacement = constants.smoothing_radius * 0.3;
    if (length(displacement) > max_displacement)
    {
        displacement = normalize(displacement) * max_displacement;
    }
    
    delta_positions[i] = vec4(displacement, 0.0);
} 