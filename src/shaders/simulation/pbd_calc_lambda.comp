#version 450

layout(local_size_x = 256) in;

layout(push_constant) uniform Constants
{
    vec4 aabb_min;
    vec4 aabb_max;
    uint particle_count;
    float rest_density;
    float smoothing_radius;
    float smoothing_radius_sq;
    float spiky_kernel_factor;
    float spiky_grad_kernel_factor;
    float constraint_epsilon;
    float relaxation_factor;
    float grid_size;
    uint max_neighbors;
}
constants;

layout(binding = 0) readonly buffer PredictedPositionBuffer
{
    vec4 predicted_positions[];
};

layout(binding = 1) readonly buffer DensityBuffer
{
    float densities[];
};

layout(binding = 2) readonly buffer ContactsBuffer
{
    uint contacts[];
};

layout(binding = 3) readonly buffer ContactCountsBuffer
{
    uint contact_counts[];
};

layout(binding = 4) buffer LambdaBuffer
{
    float lambdas[];
};

// Spiky核函数的梯度：W_spiky_grad(r, h) = -45 / (π * h^6) * (h - |r|)^2 * r / |r|
vec3 spiky_gradient(vec3 r_vec, float r, float h)
{
    if (r >= h || r == 0.0) return vec3(0.0);
    
    // 数值稳定性保护：避免极小距离导致的除零或溢出
    const float min_distance = 1e-6; // 1微米最小距离阈值
    if (r < min_distance) {
        // 对于极小距离，使用线性近似或返回零梯度
        // 避免奇点处的数值不稳定
        return vec3(0.0);
    }
    
    float h_minus_r = h - r;
    float factor = constants.spiky_grad_kernel_factor * h_minus_r * h_minus_r / r;
    
    vec3 gradient = factor * r_vec;
    float gradient_magnitude = length(gradient);
    const float max_gradient = 1e6;
    
    if (gradient_magnitude > max_gradient) {
        gradient = normalize(gradient) * max_gradient;
    }
    
    return gradient;
}

// 计算密度约束C_i = max(ρ_i / ρ_0 - 1, 0)
float density_constraint(float density)
{
    float constraint = density / constants.rest_density - 1.0;
    return max(constraint, 0.0); // 不等式约束，只处理过密情况
}

void main()
{
    uint i = gl_GlobalInvocationID.x;
    if (i >= constants.particle_count)
        return;

    vec3 pos_i = predicted_positions[i].xyz;
    float density_i = densities[i];
    
    // 计算密度约束值
    float constraint = density_constraint(density_i);
    
    // 如果约束已经满足，λ = 0
    if (constraint < constants.constraint_epsilon)
    {
        lambdas[i] = 0.0;
        return;
    }
    
    // 计算约束梯度：∇_i C_i = (1/ρ_0) * ∇_i ρ_i
    // ∇_{pk} C_i = (1/ρ_0) * Σ_j ∇_{pk} W(p_i - p_j, h)
    float gradient_sum_sq = 0.0;
    vec3 gradient_i = vec3(0.0);
    
    uint neighbor_count = contact_counts[i];
    const float mass = 0.001;

    uint overlapping_particles = 0;
    
    for (uint n = 0; n < neighbor_count; n++)
    {
        uint j = contacts[i * constants.max_neighbors + n];
        if (j >= constants.particle_count || j == i)
            continue;
            
        vec3 pos_j = predicted_positions[j].xyz;
        vec3 r_vec = pos_i - pos_j;
        float r = length(r_vec);
        
        if (r < constants.smoothing_radius)
        {
            vec3 density_grad;
            
            if (r > 0.0) {
                // 使用Spiky梯度
                density_grad = mass * spiky_gradient(r_vec, r, constants.smoothing_radius);
            } else {
                // 特殊情况：完全重叠的粒子
                // 为重叠粒子创建人工排斥梯度，基于粒子ID确定方向
                overlapping_particles++;
                vec3 artificial_direction;
                if (i < j) {
                    artificial_direction = vec3(-1.0, 0.0, 0.0);
                } else {
                    artificial_direction = vec3(1.0, 0.0, 0.0);
                }

                artificial_direction.y = sin(float(i) * 2.0) * 0.5;
                artificial_direction.z = cos(float(i) * 3.0) * 0.5;
                artificial_direction = normalize(artificial_direction);

                float artificial_gradient_magnitude = mass * constants.spiky_grad_kernel_factor * 
                    constants.smoothing_radius * constants.smoothing_radius;
                
                density_grad = artificial_gradient_magnitude * artificial_direction;
            }
            
            gradient_i += density_grad;
            
            // 计算邻居j对约束梯度的贡献：∇_j C_i = (1/ρ_0) * ∇_j ρ_i
            // ∇_j ρ_i = m_i * ∇_j W(p_i - p_j, h) = -m_i * ∇W(p_i - p_j, h)
            vec3 constraint_grad_j = -(1.0 / constants.rest_density) * density_grad;
            gradient_sum_sq += dot(constraint_grad_j, constraint_grad_j);
        }
    }
    
    // 约束梯度：∇_i C_i = (1/ρ_0) * ∇_i ρ_i
    vec3 constraint_grad_i = (1.0 / constants.rest_density) * gradient_i;
    gradient_sum_sq += dot(constraint_grad_i, constraint_grad_i);
    
    // 拉格朗日乘数：λ_i = -C_i / (Σ_k |∇_k C_i|² + ε)
    float lambda = 0.0;
    if (gradient_sum_sq > constants.constraint_epsilon)
    {
        lambda = -constraint / (gradient_sum_sq + constants.constraint_epsilon);
    }
    
    float max_lambda = 100.0;
    lambda = clamp(lambda, -max_lambda, max_lambda);
    
    lambdas[i] = lambda;
} 