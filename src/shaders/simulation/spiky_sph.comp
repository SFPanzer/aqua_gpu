#version 450

layout(local_size_x = 256) in;

layout(push_constant) uniform Constants
{
    uint particle_count;
    float mass;
    float smoothing_radius;
    float smoothing_radius_sq;
    float spiky_kernel_factor;  // 改为使用Spiky核
    float grid_size;
    uint max_neighbors; // 最大邻域粒子数，设为64
}
constants;

layout(binding = 0) readonly buffer PredictedPositionBuffer
{
    vec4 predicted_positions[];
};

layout(binding = 1) writeonly buffer DensityBuffer
{
    float densities[];
};

layout(binding = 2) readonly buffer SortedIndexBuffer
{
    uint sorted_indices[];
};

layout(binding = 3) readonly buffer CellStartBuffer
{
    uint cell_start[];
};

layout(binding = 4) readonly buffer CellEndBuffer
{
    uint cell_end[];
};

// Spiky kernel for density calculation - 与PBD约束保持一致
// 参考博客中的公式：W_spiky(r, h) = 15 / (π * h^6) * (h - |r|)^3 if |r| < h, 0 otherwise
float spiky_kernel(float r, float h)
{
    if (r >= h) return 0.0;
    float h_minus_r = h - r;
    return constants.spiky_kernel_factor * h_minus_r * h_minus_r * h_minus_r;
}

// Morton编码函数
uint expandBits(uint v)
{
    v = (v * 0x00010001u) & 0xFF0000FFu;
    v = (v * 0x00000101u) & 0x0F00F00Fu;
    v = (v * 0x00000011u) & 0xC30C30C3u;
    v = (v * 0x00000005u) & 0x49249249u;
    return v;
}

uint morton3D(uvec3 grid_pos)
{
    return (expandBits(grid_pos.x) << 0) | (expandBits(grid_pos.y) << 1) | (expandBits(grid_pos.z) << 2);
}

// 计算给定3D网格位置的Morton码
uint calculateMortonCode(ivec3 grid_pos)
{
    uvec3 pos = uvec3(grid_pos & 0xFFFFFFFF);
    return morton3D(pos);
}

void main()
{
    uint i = gl_GlobalInvocationID.x;
    if (i >= constants.particle_count)
        return;

    vec3 pos_i = predicted_positions[i].xyz;
    
    // 添加自密度贡献：每个粒子对自己的密度贡献
    // 在核函数中心(r=0)处的值是最大值
    float density = constants.mass * spiky_kernel(0.0, constants.smoothing_radius);
    uint neighbors_checked = 0;
    
    // 计算当前粒子所在的网格位置
    ivec3 grid_pos = ivec3(floor(pos_i / constants.grid_size));
    
    // 优化的cell遍历顺序：按距离优先
    // 1. 先处理自己的cell (0,0,0) - 最重要的邻居
    // 2. 再处理面邻居 (±1,0,0), (0,±1,0), (0,0,±1) - 6个
    // 3. 然后处理边邻居 - 12个  
    // 4. 最后处理角邻居 (±1,±1,±1) - 8个
    
    // 定义按优先级排序的cell偏移
    const int cell_offsets[27][3] = {
        // 自己的cell (距离=0)
        {0, 0, 0},
        
        // 面邻居 (距离=1, 6个)
        {-1, 0, 0}, {1, 0, 0}, {0, -1, 0}, {0, 1, 0}, {0, 0, -1}, {0, 0, 1},
        
        // 边邻居 (距离=√2, 12个)
        {-1, -1, 0}, {-1, 1, 0}, {1, -1, 0}, {1, 1, 0},
        {-1, 0, -1}, {-1, 0, 1}, {1, 0, -1}, {1, 0, 1},
        {0, -1, -1}, {0, -1, 1}, {0, 1, -1}, {0, 1, 1},
        
        // 角邻居 (距离=√3, 8个)
        {-1, -1, -1}, {-1, -1, 1}, {-1, 1, -1}, {-1, 1, 1},
        {1, -1, -1}, {1, -1, 1}, {1, 1, -1}, {1, 1, 1}
    };
    
    // 按优先级顺序搜索所有27个cell
    for (int cell_idx = 0; cell_idx < 27 && neighbors_checked < constants.max_neighbors; cell_idx++)
    {
        // 计算目标cell的网格位置
        ivec3 neighbor_grid = grid_pos + ivec3(
            cell_offsets[cell_idx][0],
            cell_offsets[cell_idx][1], 
            cell_offsets[cell_idx][2]
        );
        
        // 计算Morton码并取低16位作为cell索引
        uint morton_code = calculateMortonCode(neighbor_grid);
        uint cell_index = morton_code & 0xFFFFu;
        
        // 获取该cell中粒子的范围
        uint start_idx = cell_start[cell_index];
        uint end_idx = cell_end[cell_index];
        
        // 检查cell范围的有效性
        if (start_idx == 0xFFFFFFFFu || end_idx == 0xFFFFFFFFu || start_idx >= end_idx)
            continue;
            
        // 遍历该cell中的所有粒子
        for (uint idx = start_idx; idx < end_idx && neighbors_checked < constants.max_neighbors; idx++)
        {
            if (idx >= constants.particle_count)
                break;
                
            uint j = sorted_indices[idx];
            if (j >= constants.particle_count || j == i)  // 跳过自身，因为已经添加了自密度贡献
                continue;
                
            vec3 pos_j = predicted_positions[j].xyz;
            vec3 r_vec = pos_i - pos_j;
            float r = length(r_vec);
            
            if (r < constants.smoothing_radius)
            {
                density += constants.mass * spiky_kernel(r, constants.smoothing_radius);
            }
            
            neighbors_checked++;
        }
    }
    
    // Store density for PBD constraint solving
    densities[i] = density;
} 